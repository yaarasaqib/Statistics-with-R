#### 4. Making Programs with R ######

### Loops (for or while)

#1

for( i in 1:5){
  print(i)
}

#2
for( i in seq(1,10,by=2)) print(i)

#3
days <- c("Mon","Tue","Wed")
for(i in days) print(i)

#4 while loop

i <- 1
while(i <3){
  print(i)
  i=i+1
}

# condition (if-else)

#5

come= "late"

if(come=="early"){
  print("Dont Cook food.")
}else{
  print("cook food")
}

#6 repeat loop

i <- 1
repeat{
  print(i)
  i <- i+1
  if(i>3) break
}
########################
### Predefined Function

# 7 Calculate mean of each column

# apply func applied on the margin of the table
set.seed(1234)
X <- matrix(sample(1:20,20),ncol=4)
X
apply(X, MARGIN=2,FUN=mean)  # margin 1 or 2 are row or col resp

# additional arg to remove na values

X[1,1] <- NA 
apply(X, MARGIN=2,FUN=mean,na.rm=TRUE) 

# due to frequent use we have shortcut

colMeans(X,na.rm=TRUE)

colSums(X)
rowSums(X,na.rm=TRUE)

# Margin 3 means depth

set.seed(1234)

Y <- array(sample(24),dim=c(4,3,2))
Y

apply(Y,MARGIN=c(1,2),FUN=sum, na.rm = TRUE)

# we can apply our own func

MyFunc <- function(x,y){
  z=x+sqrt(y)
  return(1/z)
}

set.seed(1234)
M<- matrix(sample(20),ncol=4)
apply(M,MARGIN= c(1,2),FUN=MyFunc,y=2)

## tapply func apply on same func not on the margin of table
# but instead at each level of factor or combination of factor

z <- 1:5
vec1<- c(rep("A1",2),rep("A2",2),rep("A3",1))
vec1
vec2<- c(rep("B1",3),rep("B2",2))
vec2

tapply(z,vec1,sum)

tapply(z,list(vec1,vec2),sum)

#sapply func is equiv to lapply , it yields a matrix or vec

set.seed(545)

mat1 <- matrix(sample(12),ncol=4)
mat1

mat2 <- matrix(sample(4),ncol=2)
mat2

mylist<- list(matrix1= mat1, matrix2= mat2)

lapply(mylist,mean)

# possible to use apply func as FUNC func
lapply(mylist, apply,2, sum,na.rm=T)

# aggregate function works on data frame

Z <- 1:5
T <- 5:1
vec1 <- c(rep("A1",2),rep("A2",2),rep("A3",1))
vec2 <- c(rep("B1",3),rep("B2",2))
df <-  data.frame(Z,T,vec1,vec2)
df
aggregate(df[,1:2],list(FactorA=vec1),sum)

# subgroup can also be defined by a vector generated by
# two factors:

aggregate(df[,1:2],list(factorA=vec1,factorB=vec2),sum)


# sweep func is used to apply one single procedure to
# all the margin

set.seed(1234)
X <- matrix(sample(12),ncol=3)

mean.X <- apply(X,2,mean)
mean.X

sd.X <- apply(X,2,sd)
sd.X

Xc<- sweep(X,2, mean.X,FUN="-" )
Xc

Xcr <- sweep(Xc,2,sd.X, FUN="/")
Xcr

scale(X)  # Xcr same as scale

set.seed(1234)
T <- rnorm(100)
Z <- rnorm(100)+ 3*T+5

vec1 <- c(rep("A1",25),rep("A2",25),rep("A3",50))
don <- data.frame(Z,T)

by(don,list(FactorA=vec1),summary)

by(don,list(FactorA=vec1),sum)

#calculate regression coef for each level of the var vec1

myfunction <- function(x){
  summary(lm(Z~T),data=x)$coef
}

by(don,vec1, myfunction)

# replicate function which is used to repeat n times

set.seed(1234)
replicate(n=8,mean(rnorm(100)))

# outer func is used to repeat func for each occurence
# of combination of two vecs

Month <- c("Jan","Feb","Mar")
Year <- 2008:2010
outer(Month,Year, FUN="paste")

# can use separator

outer(Month,Year, FUN=paste, sep="-")

# Func to sum 1:n

mysum <- function(n){
  result <- sum(1:n)
  return(result)
}

mysum(3)

res<- mysum(3)
res

# the above func may be improved

mysum <- function(n){
  if(n<0) stop("n must be positive integer")
  if(floor(n)!=n) warning(paste("rounds",n,"as",floor(n)))
  result= sum(1:n)
  return(result)
}

mysum(4.325)

# Create a function to find soln of quadratic eqsn

myFun <- function(factor1,factor2){
  res1 <- table(factor1,factor2)
  selection <- which(res1==0, arr.ind=TRUE)
  res2<- matrix("",nrow=nrow(selection),ncol=2)
  res2[,1]<- levels(factor1)[selection[,1]]
  res2[,2]<- levels(factor2)[selection[,2]]
  return(list(tab=res1,level=res2))
} 

tension<- factor(c(rep("Low",5),rep("High",5)))
wool <- factor(c(rep("Ang",3),rep("Mer",3),rep("Tex",4)))


myFun(tension,wool)

# ax^2+bx+c

Quad_soln <- function(a,b,c){
  D=b^2-4*a*c
  D= as.complex(D)
  x= (-b+sqrt(D))/2
  y=(-b-sqrt(D))/2
  return(paste("The solutions are",x ,"and",y))
}


# programme n! using prod func

n=8
{x<- 1:n
prod(x)}

# programme that factorial using for loops:


n=7
num=1

{for(i in 1:n){
  num= num*i
}
print(num)}


